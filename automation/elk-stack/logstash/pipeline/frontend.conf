#############################################################################
# Logstash Pipeline: Frontend Browser Logs
# Purpose: Process browser console logs (CRITICAL: Needs PII sanitization!)
# WARNING: Frontend logs may contain user inputs with PII!
#############################################################################

input {
  pipeline {
    address => "frontend"
  }
}

#############################################################################
# FILTER: Parse + PII Sanitization
#############################################################################
filter {
  # Parse JSON payload
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "frontend_data"
    }
  }

  # Extract Raw Message
  if [frontend_data][message] {
    mutate {
      add_field => { "raw_message" => "%{[frontend_data][message]}" }
    }
  }
  else {
    mutate {
      add_field => { "raw_message" => "%{message}" }
    }
  }

  #---------------------------------------------------------------------------
  # PII SANITIZATION (Option 1: Ruby Inline - MVP)
  #---------------------------------------------------------------------------
  ruby {
    code => '
      # PII Regex Patterns
      EMAIL_PATTERN = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/
      PHONE_PATTERN = /\b(?:\+?\d{1,3}[\s-]?)?\(?\d{1,4}\)?[\s-]?\d{1,4}[\s-]?\d{1,9}\b/
      CARD_PATTERN = /\b(?:\d{4}[\s-]?){3}\d{4}\b/
      IBAN_PATTERN = /\b[A-Z]{2}\d{2}[A-Z0-9]{1,30}\b/

      message = event.get("raw_message").to_s
      original_message = message.dup

      # Counters
      emails_redacted = 0
      phones_redacted = 0
      cards_redacted = 0
      ibans_redacted = 0

      # Email Redaction
      message.gsub!(EMAIL_PATTERN) do |email|
        emails_redacted += 1
        user, domain = email.split("@")
        "#{user[0]}**@#{domain}"
      end

      # Phone Redaction
      message.gsub!(PHONE_PATTERN) do |phone|
        phones_redacted += 1
        "[PHONE]"
      end

      # Card Redaction
      message.gsub!(CARD_PATTERN) do |card|
        cards_redacted += 1
        "[CARD]"
      end

      # IBAN Redaction
      message.gsub!(IBAN_PATTERN) do |iban|
        ibans_redacted += 1
        "[IBAN]"
      end

      # Update Event
      event.set("message", message)
      event.set("pii_emails_redacted", emails_redacted)
      event.set("pii_phones_redacted", phones_redacted)
      event.set("pii_cards_redacted", cards_redacted)
      event.set("pii_ibans_redacted", ibans_redacted)
      event.set("pii_total_detected", emails_redacted + phones_redacted + cards_redacted + ibans_redacted)

      # If PII detected, add tag
      if emails_redacted + phones_redacted + cards_redacted + ibans_redacted > 0
        event.set("[tags]", (event.get("tags") || []) + ["pii_sanitized"])
      end
    '
  }

  #---------------------------------------------------------------------------
  # Alternative: HTTP Filter to FastAPI (uncomment for production)
  #---------------------------------------------------------------------------
  # http {
  #   url => "${FASTAPI_PII_ENDPOINT}"
  #   verb => "POST"
  #   headers => {
  #     "Content-Type" => "application/json"
  #     "Authorization" => "Bearer ${LOGSTASH_API_TOKEN}"
  #   }
  #   body => {
  #     "text" => "%{raw_message}"
  #     "pii_types" => ["email", "phone", "card", "iban", "jwt", "ip", "secret"]
  #     "strategy" => "mask"
  #     "include_metrics" => true
  #   }
  #   target_body => "pii_result"
  #   timeout => 1
  #   tag_on_timeout => ["http_timeout"]
  # }
  #
  # # Extract Sanitized Text + Metrics
  # if [pii_result] {
  #   mutate {
  #     replace => { "message" => "%{[pii_result][sanitized_text]}" }
  #     add_field => {
  #       "pii_emails_redacted" => "%{[pii_result][metrics][emails_redacted]}"
  #       "pii_cards_redacted" => "%{[pii_result][metrics][cards_redacted]}"
  #       "pii_total_detected" => "%{[pii_result][metrics][total_pii_detected]}"
  #     }
  #   }
  # }

  # Extract Additional Frontend Fields
  if [frontend_data] {
    mutate {
      add_field => {
        "service" => "frontend"
        "level" => "%{[frontend_data][level]}"
        "browser" => "%{[frontend_data][browser]}"
        "page_url" => "%{[frontend_data][page_url]}"
        "user_agent" => "%{[frontend_data][user_agent]}"
      }
    }
  }

  # Environment Detection (from page_url)
  if [page_url] =~ /stg\./ or [page_url] =~ /staging\./ {
    mutate { add_field => { "environment" => "staging" } }
  }
  else {
    mutate { add_field => { "environment" => "production" } }
  }

  # Clean Up
  mutate {
    remove_field => ["frontend_data", "raw_message", "pii_result"]
  }
}

#############################################################################
# OUTPUT: Elasticsearch
#############################################################################
output {
  # Send to Operational Logs Index
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "elastic"
    password => "${ELASTICSEARCH_PASSWORD}"
    index => "logs-operational-%{+YYYY.MM.dd}"
    data_stream => false
  }

  # If PII Detected â†’ Send to Compliance Index (for audit trail)
  if "pii_sanitized" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTICSEARCH_PASSWORD}"
      index => "logs-compliance-%{+YYYY.MM.dd}"
      data_stream => false
    }
  }
}
